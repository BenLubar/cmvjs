// AUTOMATICALLY GENERATED FILE. DO NOT EDIT.

package main

var workerjs = js(asset.init(asset{Name: "worker.js", Content: "" +
	"\"use strict\";\n\nimportScripts('zlib.min.js');\n\nonmessage = function(e) {\n\tswitch (e.data.mode) {\n\tcase 'start':\n\t\tstartCMV(e.data.file);\n\t\tbreak;\n\tcase 'stop':\n\t\tstopCMV(e.data.file);\n\t\tbreak;\n\tdefault:\n\t\tthrow 'unknown mode ' + e.data.mode;\n\t}\n};\n\nvar movies = {};\n\nfunction startCMV(path) {\n\tvar movie = {\n\t\txhr:        new XMLHttpRequest(),\n\t\tpath:       path,\n\t\tversion:    null,\n\t\twidth:      null,\n\t\theight:     null,\n\t\tindex:      null,\n\t\ttoParse:    [],\n\t\tparseIndex: 0\n\t};\n\tmovie.xhr.open('GET', path, true);\n\tmovie.xhr.overrideMimeType('text/plain; charset=x-user-defined');\n\tmovie.xhr.onprogress = cmvProgress.bind(movie);\n\tmovie.xhr.send(null);\n\n\tmovies[path] = movie;\n}\n\nfunction stopCMV(path) {\n\tif (!(path in movies)) {\n\t\tconsole.log(path + ' already stopped');\n\t\treturn;\n\t}\n\tmovies[path].xhr.abort();\n\tdelete movies[path];\n}\n\nfunction cmvProgress(e) {\n\tif (this.version === null && e.loaded >= 4 * 1) {\n\t\tthis.version = uint32(this.xhr.responseText, 4 * 0);\n\t\tconsole.log(this.path + ' version: ' + this.version);\n\t\tif (this.version < 10000 || this.version > 10001) {\n\t\t\tthrow this.path + ' unsupported cmv version ' + this.version;\n\t\t}\n\t}\n\tif (this.width === null && e.loaded >= 4 * 2) {\n\t\tthis.width = uint32(this.xhr.responseText, 4 * 1);\n\t\tconsole.log(this.path + ' width: ' + this.width);\n\t}\n\tif (this.height === null && e.loaded >= 4 * 3) {\n\t\tthis.height = uint32(this.xhr.responseText, 4 * 2);\n\t\tconsole.log(this.path + ' height: ' + this.height);\n\t}\n\tif (this.index === null && e.loaded >= 4 * 5) {\n\t\tif (this.version >= 10001) {\n\t\t\t// skip sound information for now.\n\t\t\tvar i = 4 * 5 + uint32(this.xhr.responseText, 4 * 4) * 50 + 200 * 16 * 4;\n\t\t\tif (e.loaded >= i) {\n\t\t\t\tthis.index = i;\n\t\t\t\tconsole.log(this.path + ' finished header');\n\t\t\t}\n\t\t} else {\n\t\t\tthis.index = 4 * 4;\n\t\t\tconsole.log(this.path + ' finished header');\n\t\t}\n\t}\n\twhile (this.index !== null && e.loaded >= this.index + 4) {\n\t\tvar length = uint32(this.xhr.responseText, this.index);\n\t\tif (e.loaded >= this.index + 4 + length) {\n\t\t\tvar compressed = new Uint8Array(length);\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tcompressed[i] = this.xhr.responseText.charCodeAt(this.index + 4 + i) & 0xFF;\n\t\t\t}\n\t\t\tvar data = new Zlib.Inflate(compressed).decompress();\n\t\t\tthis.index += 4 + length;\n\t\t\tthis.toParse.push(data);\n\t\t\tconsole.log(this.path + ' decompressed: ' + length + ' -> ' + data.length);\n\n\t\t\tthis.parseIndex = extractFrames(this.path, this.toParse, this.parseIndex, this.version, this.width, this.height);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nfunction extractFrames(path, toParse, index, version, width, height) {\n\tvar length = width * height * 2;\n\n\twhile (toParse.length) {\n\t\tvar remaining = -index;\n\t\ttoParse.forEach(function(data) {\n\t\t\tremaining += data.length;\n\t\t});\n\t\tif (remaining < length) {\n\t\t\treturn index;\n\t\t}\n\n\t\tvar frame = new Uint8Array(length);\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\twhile (index >= toParse[0].length) {\n\t\t\t\ttoParse.shift();\n\t\t\t\tindex = 0;\n\t\t\t}\n\t\t\tframe[i] = toParse[0][index];\n\t\t\tindex++;\n\t\t}\n\t\tpostMessage({frame: {data: frame, width: width, height: height}, file: path});\n\t}\n\treturn 0;\n}\n\nfunction uint32(data, off) {\n\treturn ((data.charCodeAt(off + 0) & 0xFF) <<  0) +\n\t       ((data.charCodeAt(off + 1) & 0xFF) <<  8) +\n\t       ((data.charCodeAt(off + 2) & 0xFF) << 16) +\n\t       ((data.charCodeAt(off + 3) & 0xFF) << 24);\n}\n" +
	""}))
